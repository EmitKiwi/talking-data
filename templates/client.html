<!DOCTYPE html>
<html>
<head>    
  <title>Talking Data</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black" />
	<link rel="apple-touch-icon" href="/static/apple-touch-icon.png"/>
	<link rel="stylesheet" href="/static/leaflet.css" />
	<link rel="stylesheet" href="/static/style.css" />
  <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="/static/jquery-2.0.3.min.js"></script>
	<script src="/static/leaflet.js"></script> 
</head>
<body >
	<div id="map"></div>
	<div id="logo"></div>
	<script>
  
  var padding = 1000000;
  var radius = 20;
  var map = new L.Map("map")
      .addLayer(new L.TileLayer("http://{s}.tiles.mapbox.com/v3/bertspaan.map-dvysiubb/{z}/{x}/{y}.png"));
      
  map.removeControl(map.zoomControl);
  map.removeControl(map.attributionControl);
  map.setView([52.3674, 4.915], 5);        

  var svg = d3.select(map.getPanes().overlayPane).append("svg"),
      g = svg.append("g").attr("class", "leaflet-zoom-hide"),
      eg = g.append("g").attr("class", "edges"),
      vg = g.append("g").attr("class", "vertices");
      
  var bounds,
      vertices = {
    "type": "FeatureCollection",
    "features": []
  };

      
  
  map.on("mouseup", function(e) {
    var vertex = {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Point",
        coordinates: [
          e.latlng.lng,
          e.latlng.lat
        ]
      }
    };
    
    vertices.features.push(vertex);
    bounds = d3.geo.bounds(vertices);
  
    update();    
  });

  map.on("viewreset", update);
  update();

  // Reposition the SVG to cover the features.
  function update() {    
    var vertex = vg.selectAll("circle")
        .data(vertices.features)
        .attr("cx", function(d) { return project(d.geometry.coordinates)[0]; })
        .attr("cy", function(d) { return project(d.geometry.coordinates)[1]; })
        .attr("r", radius);
      
    vertex.enter().append("circle")
        .attr("cx", function(d) { return project(d.geometry.coordinates)[0]; })
        .attr("cy", function(d) { return project(d.geometry.coordinates)[1]; })
        .attr("r", radius)
        .on("mouseover", function() { d3.select(this).transition().duration(500).attr("r", radius * 1.1); } )
        .on("mouseout", function() { d3.select(this).transition().duration(500).attr("r", radius); } );

    var edge = eg.selectAll("line")
        .data(vertices.features, function(d, i) {
          return [i, (i + 1) % vertices.features.length];
        });
   
    updateEdge(edge);
    updateEdge(edge.enter().append("line"));        
        
    edge.exit().remove();
            
    if (vertices.features.length) {
      // Set SVG position, translate group
      var bottomLeft = project(bounds[0]),
          topRight = project(bounds[1]);
        
      svg.attr("width", topRight[0] - bottomLeft[0] + padding * 2)
         .attr("height", bottomLeft[1] - topRight[1] + padding * 2)
         .style("margin-left", (bottomLeft[0] - padding) + "px")
         .style("margin-top", (topRight[1] - padding) + "px");
       
      g.attr("transform", "translate(" + (-bottomLeft[0] + padding) + "," + (-topRight[1] + padding) + ")");
    }
  }
  
  function updateEdge(edge) {
    edge
      .attr("x1", function(d, i) {     
        var rx = Math.cos(angle(i)) * radius;        
        var x1 = f_x1(i);
        var x2 = f_x2(i);
        var s = (x2 > x1) ? 1 : -1;
        return x1 + rx * s; 
      })
      .attr("y1", function(d, i) { 
        var ry = Math.sin(angle(i)) * radius;
        var y1 = f_y1(i);
        var y2 = f_y2(i);
        var s = (y2 > y1) ? 1 : -1;
        return y1 + ry * s; 
      })
      .attr("x2", function(d, i) { 
        var rx = Math.cos(angle(i)) * radius;        
        var x1 = f_x1(i);
        var x2 = f_x2(i);
        var s = (x2 < x1) ? 1 : -1;
        return x2 + rx * s; 
      })
      .attr("y2", function(d, i) { 
        var ry = Math.sin(angle(i)) * radius;
        var y1 = f_y1(i);
        var y2 = f_y2(i);
        var s = (y2 < y1) ? 1 : -1;
        return y2 + ry * s; 
        
      })
      .attr("class", function(d, i) { return (i == vertices.features.length - 1) ? "last" : ""})   
  }
  
  function f_x1(i) {
    return project(vertices.features[i].geometry.coordinates)[0];
  }
  
  function f_x2(i) {
    return project(vertices.features[(i + 1) % vertices.features.length].geometry.coordinates)[0];
  }
  
  function f_y1(i) {
    return project(vertices.features[i].geometry.coordinates)[1];
  }
  
  function f_y2(i) {
    return project(vertices.features[(i + 1) % vertices.features.length].geometry.coordinates)[1];
  }

  function dx(i) {
    return d(i, 0);
  }

  function dy(i) {
    return d(i, 1);
  }
  
  function angle(i) {
    var dyi = dy(i);
    var dxi = dx(i);
    var r = 0;
    if (dxi != 0) {
      r = dy(i) / dx(i);   
    }
    return Math.atan(r);
  }
  
  function d(i, c) {
    if (vertices.length) {
      return project(vertices.features[(i + 1) % vertices.features.length].geometry.coordinates)[c] 
        - project(vertices.features[i].geometry.coordinates)[c];
    } else {
      return 0;
    }
  }

  

  

  // Use Leaflet to implement a D3 geographic projection.
  function project(x) {
    var point = map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
    return [point.x, point.y];
  }
         	
	</script>
</body>
</html>